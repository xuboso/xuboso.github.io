---
title: ElasticSearch学习笔记
date: 2025-02-24 22:43:30
tags:
  - ElasticSearch
  - 搜索
---

# ElasticSearch

### Elasticsearch 的工作原理。

Elasticsearch 是一个分布式的搜索和分析引擎，常用于大规模数据的全文本搜索、日志分析和实时数据流分析等场景。它基于 Apache Lucene 库构建，提供了一个强大、便捷的 RESTful API 来进行索引和搜索数据。

Elasticsearch 的工作原理包括以下几个关键点：

1. **索引和文档**：

   - 数据在 Elasticsearch 中被组织为一个或多个索引（Index），每个索引包含若干文档（Document）。每个文档是 JSON 格式的，包含了一系列属性（fields），类似于数据库中的行。

2. **分片和副本**：

   - 为了可伸缩性和高可用性，每个索引可以分为多个分片（Shard），默认情况下有五个主分片。每个主分片可以有一个或多个副本（Replica），以确保数据的冗余和安全。

3. **聚合**：

   - Elasticsearch 不仅支持全文检索，还支持通过聚合（Aggregation）对数据进行复杂的分析和统计。

4. **分布式架构**：

   - Elasticsearch 的集群由一个或多个节点组成，每个节点是一个运行 Elasticsearch 的实例。分布式架构使其可以轻松扩展，以处理大量的数据和请求。

5. **全文搜索**：
   - Elasticsearch 能够通过倒排索引进行快速的全文搜索，这使其在处理文本数据时非常高效。

总之，Elasticsearch 通过其分布式索引和搜索能力，为用户提供了一个灵活和可伸缩的解决方案，用于处理和分析大量数据。

### 什么是节点、集群、索引、类型、文件夹和分片？

在 Elasticsearch 的架构中，以下是几个重要概念的定义：

1. **节点（Node）**：

   - 节点是一个运行中的 Elasticsearch 实例。一个节点在集群中承担数据存储和搜索功能。多个节点可以组成一个集群。

2. **集群（Cluster）**：

   - 集群是由一个或多个节点组成的集合，它们协同工作来存储和检索数据。集群由一个唯一的名称标识，所有属于同一集群的节点必须有相同的集群名称。

3. **索引（Index）**：

   - 索引用于存储相关文档的集合，类似数据库的概念。在一个索引中，数据通过 JSON 格式的文档形式存在。

4. **类型（Type）**：

   - 在早期版本的 Elasticsearch 中，类型用于定义索引中的文档分类。不过从 Elasticsearch 7 开始，每个索引只支持一个类型，类型的概念逐渐被淡化和放弃。

5. **分片（Shard）**：

   - 分片是一个索引的逻辑分区。每个索引可以配置多个分片。分片的设计使得 Elasticsearch 能够水平扩展，允许保存并分布大量数据。

6. **副本分片（Replica Shard）**：

   - 副本分片是主分片的副本，用于提高数据的高可用性和读性能。Elasticsearch 会在不同的节点上分配主分片和副本分片，以实现冗余。

7. **文档（Document）**：
   - 文档是存储在索引中的基本信息单元，类似于关系型数据库中的行。每个文档都是以 JSON 格式存储的。

这些概念共同组成了 Elasticsearch 的基本架构，使其可以有效地存储、搜索和分析大规模数据。

### 如何定义和创建索引？

在 Elasticsearch 中，创建索引的过程通常包括定义索引的映射（mapping）和设定索引的配置，如分片和副本的数量。以下是步骤：

1. **定义索引映射（Mapping）**：

   - 索引映射定义了索引中文档的结构，包括字段的类型。例如，字段可以是数字、字符串、日期等。

2. **创建索引**：
   - 你可以通过 Elasticsearch 的 RESTful API 创建索引。使用 HTTP 请求，以 JSON 格式指定索引的设置和映射。

示例创建索引的 API 请求：

```bash
PUT /my_index
{
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 2
  },
  "mappings": {
    "properties": {
      "field1": { "type": "text" },
      "field2": { "type": "keyword" },
      "field3": { "type": "date" },
      "field4": { "type": "integer" }
    }
  }
}
```

在这个例子中，创建了一个名为`my_index`的索引：

- **settings**：定义了索引的配置，包括分片数量（`number_of_shards`）和副本数量（`number_of_replicas`）。
- **mappings**：指定了文档中字段的数据类型，如`field1`是文本类型，`field2`是关键字类型，`field3`是日期类型，而`field4`是整数类型。

你可以根据需求调整这些设置和映射，以适应你的数据模型和查询性能要求。

### 什么是分片？为什么需要分片？

分片（Shard）是 Elasticsearch 中一种重要的概念，它将索引划分为若干更小的部分。这种分区可以提高数据的管理和检索能力。以下是关于分片的详细介绍：

1. **什么是分片**：

   - 分片是一个独立的搜索引擎实例。每个分片都包含索引的一部分数据，并能独立执行 CRUD（创建、读取、更新、删除）和搜索操作。
   - 每个索引可以配置一个或多个主分片（Primary Shard），这些分片共同存储索引中的所有数据。

2. **需要分片的原因**：

   - **可扩展性**：单个节点通常无法存储或高效管理海量数据。通过将索引分为多个分片，可以将数据和负载分布到集群中的多个节点上，从而实现水平扩展。
   - **并行处理**：多个分片可以分布在多个节点上，这意味着 Elasticsearch 可以并行进行数据操作，提高处理速度。
   - **高可用性**：通过创建分片的副本（Replica Shards），可以在集群节点出现故障时提供数据冗余和高可用性。

3. **分片的副本**：
   - 每个主分片可以有一个或多个副本分片（Replica Shard）。副本分片不仅用于灾难恢复，也可以用于分担读操作的负载，提高查询效率。

通过分片机制，Elasticsearch 能够处理大规模数据集，同时提供高性能和高可用性，使其表现出色，特别是在需要快速响应和处理大量数据的应用场景中。

### 分片和副本之间的区别是什么？

片（Shard）和副本（Replica）是 Elasticsearch 中两个密切相关但有不同功能的概念。

1. **分片（Primary Shard）**：

   - **作用**：每个索引的数据都被划分为若干分片，每个分片是完整索引的数据的一个子集。分片的主要作用是实现数据分发和并行计算，从而提高 Elasticsearch 的吞吐量和性能。
   - **数量**：每个索引的主分片数量是在索引创建时设定的，并且一旦索引创建就不能更改。

2. **副本（Replica Shard）**：
   - **作用**：副本是主分片的完整副本，主要用于提供冗余，以实现高可用性和故障恢复。此外，副本帮助分担查询负载，以提高读取性能。
   - **数量**：每个主分片可以有一个或多个副本。副本的数量可以动态调整。

**区别**：

- **目的**：主分片的目的是对数据进行分区以实现扩展性；副本的目的是提供冗余和提高读取的容错能力。
- **数据写入**：数据只能写入主分片，而副本接收来自主分片的数据同步。
- **容灾恢复**：当主分片故障时，集群可以选举一个副本作为新的主分片以保证数据的可用性。

这种分片和副本的设计，使 Elasticsearch 能够高效地处理大规模的读取和写入请求，同时保证数据不丢失。

### 如何配置分片数量和副本数量？

配置分片数量和副本数量是在 Elasticsearch 中创建索引时非常重要的步骤。以下是如何进行这些配置的方法：

1. **分片数量（number_of_shards）**：

   - 分片数量决定了索引将如何分布在集群的多个节点上。配置时要考虑数据量和节点数量。
   - 分片数量在索引创建的时候设置，之后无法更改。因此，必须提前根据预期数据量和集群规模来规划。

2. **副本数量（number_of_replicas）**：
   - 副本数量指的是每个主分片的副本数量。副本可以动态调整。
   - 增加副本数量有助于提高系统的读取性能和提供数据的冗余性。

**配置示例**：

当你创建一个新的索引时，可以通过如下的 HTTP 请求设置分片和副本的数量：

```bash
PUT /my_index
{
  "settings": {
    "number_of_shards": 5,
    "number_of_replicas": 1
  }
}
```

在这个示例中：

- `number_of_shards`被设置为`5`，表示该索引将拥有 5 个主分片。
- `number_of_replicas`被设置为`1`，表示每个主分片将有一个副本。

**注意事项**：

- 分片数量应考虑集群的硬件配置以及预期的数据增长。
- 副本提供高可用性，因此至少要有一个副本来确保系统能够在单节点故障时保持可用性。
- 可以在运行时动态调整副本数量，但分片数量必须在索引创建时确定并且不能以后更改。

### 在使用过程中如何动态调整分片/副本？

在 Elasticsearch 中，虽然分片数量一旦指定就不能修改，但可以动态调整副本（replica）的数量。这是如何进行调整的步骤：

1. **动态调整副本数量**：
   - 调整副本数量的目的是增强读取性能和提高数据的冗余性。你可以根据系统负载或可用性需求来增减副本数量。

**调整副本的 API 请求示例**：

可以通过以下 API 请求动态调整某个索引的副本数量：

```bash
PUT /my_index/_settings
{
  "number_of_replicas": 2
}
```

在这个例子中，我们把索引`my_index`的副本数量设置为`2`。

**注意事项**：

- 副本数量可以动态增加或减少，但每个操作可能会导致数据重分配，消耗系统资源。
- 如果你减少副本，可能会在数据节点故障时降低数据的可用性。
- 增加太多副本可能导致资源浪费，因为每个副本都需要存储和维持完整的数据集。

通过这种设置，虽然不能直接调整分片数量，但副本的调整给了很大的灵活性来优化 Elasticsearch 集群的性能和可用性。

### 解释一下匹配查询与术语查询的区别。

在 Elasticsearch 中，匹配查询（`match`查询）和术语查询（`term`查询）是两种最常用的查询类型，它们用于不同的目的，处理查询的方式也有所不同：

1. **匹配查询（Match Query）**：
   - **用途**: 用于全文搜索。适合在分词的字段上进行搜索，比如文本字段。
   - **行为**: `match`查询会对搜索词进行分词，然后在倒排索引中查找这些词的匹配项。
   - **场景**: 如果你在搜索类似于一段文本而非精确数值或关键词时，这种查询最为合适。
   - **示例**:

```json
{
  "query": {
    "match": {
      "field_name": "search term"
    }
  }
}
```

2. **术语查询（Term Query）**：
   - **用途**: 用于精确匹配，适合未分词的字段，如关键词、ID、标签、数值字段。
   - **行为**: `term`查询会直接在索引中查找完全匹配的词项。不进行分词操作。
   - **场景**: 适用于精确搜索（如搜索一个特定的用户 ID），而非文本分析的场合。
   - **示例**:
     ```json
     {
       "query": {
         "term": {
           "field_name": "exactTerm"
         }
       }
     }
     ```

**区别总结**:

- `match`查询适合应用于需要文本分析（即需要分词）的场景，而`term`查询则用于精确值匹配，不适合分词后搜索。
- 使用`match`查询时，Elasticsearch 会根据字段的映射类型和相关分析器进行分词等预处理，而`term`查询直接查找精确匹配的值。

选择合适的查询类型有助于获得更准确的搜索结果，优化系统性能。

### 如何优化查询性能？

优化 Elasticsearch 查询性能可以提高数据检索速度并降低资源消耗。以下是一些关键的优化策略：

1. **使用适当的查询类型**：

   - 根据需求选择合适的查询类型。对于全文搜索，使用`match`查询，而对于精确匹配，使用`term`查询。

2. **减少数据传输**：

   - 选择合适的字段并仅检索需要的字段。使用`_source`参数仅返回需要的字段数据。

3. **过滤与查询分离**：

   - 利用`filter`上下文来替代`query`上下文进行无需评分的过滤操作，这样 Elasticsearch 可以利用缓存提高性能。

4. **合理配置索引与映射**：

   - 为常用搜索字段设置合适的分词器，避免不必要的索引字段。
   - 使用`keyword`类型字段存储需要做精确匹配的文本。

5. **利用缓存**：

   - 对频繁执行的静态查询，利用 Elasticsearch 的查询缓存机制。

6. **调整分片和副本**：

   - 通过配置适当的分片和副本数量，确保查询负载在集群中均匀分布。

7. **数据归档和多索引管理**：

   - 对于历史数据，考虑使用不同的索引或归档方案，以减少热数据集的大小。

8. **硬件和集群优化**：

   - 确保有足够的内存、CPU 和磁盘 I/O，以支持 Elasticsearch 的需求。

9. **使用聚合适当**：
   - 在使用聚合（aggregations）时，尽量限定其作用范围以有限制结果集的规模。

这些优化策略需要根据特定应用场景来灵活运用，以在不增加不必要的资源消耗的前提下获得最佳性能。定期监控系统的性能表现和瓶颈，也是保持系统高效运作的重要手段。

### 如何进行索引的备份和恢复？

Elasticsearch 提供了快照和恢复的功能以备份和恢复索引数据。这种机制通过一个称为"快照/恢复（snapshot/restore）"的 API 来管理。以下是如何进行索引备份和恢复的步骤：

#### 索引备份

1. **设置存储库**：
   - 首先需要创建一个用于存储快照的存储库（repository）。存储库可以是共享文件系统、Amazon S3、HDFS 等。
   - 创建文件系统类型存储库的示例：
   ```bash
       PUT _snapshot/my_backup
   {
     "type": "fs",
     "settings": {
       "location": "/mount/backups/my_backup"
     }
   }
   ```
2. **创建快照**：
   - 使用快照 API 创建快照。可以指定单个索引或者所有索引。
   - 创建快照的示例：
   ```bash
       PUT _snapshot/my_backup/snapshot_1
    {
      "indices": "index_1,index_2",
      "ignore_unavailable": true,
      "include_global_state": false
    }
   ```

#### 索引恢复

1. **从快照中恢复**：
   - 使用恢复 API 从快照中恢复索引。可以选择恢复到不同的集群或同一集群。
   - 恢复索引的示例：
   ```bash
       POST _snapshot/my_backup/snapshot_1/_restore
    {
      "indices": "index_1",
      "ignore_unavailable": true,
      "include_global_state": false
    }
   ```

在开始备份和恢复前，确保：

- 所有节点可以访问快照存储库。
- 提前评估恢复操作对性能的影响，特别是在繁忙的集群中。
- 快照过程一般不会影响集群的正常运行，但仍建议在低流量时段使用。

通过快照和恢复机制，可以有效备份和恢复 Elasticsearch 的数据，确保数据安全和快速恢复。

### 如何处理索引的热/冷数据管理？

在 Elasticsearch 中，处理索引的热/冷数据管理是一种优化存储和查询性能的策略。热/冷数据管理将活跃数据（热数据）和非活跃数据（冷数据）区分开来，并且分别存储和处理，以减少资源消耗并优化查找性能。

### 热/冷数据管理策略

1. **定义热和冷数据**：

   - **热数据**是近期活跃使用或查询频繁的数据。通常存储在高性能硬件（如 SSD）上以提高查询性能。
   - **冷数据**是历史性、查询频率低的数据。通常可以存储在大容量但低成本的存储上（如 HDD）。

2. **使用索引生命周期管理（ILM）**：

   - Elasticsearch 提供了索引生命周期管理（ILM）功能，可以根据数据的生命周期阶段自动迁移索引数据。
   - 配置 ILM 策略时，你可以指定索引生命周期阶段，如热、温、冷、删除。

3. **创建 ILM 策略**：
   - 以下是一个简单 ILM 策略的示例，它定义了数据从热到冷的迁移：
   ```json
       PUT _ilm/policy/my_policy
    {
      "policy": {
        "phases": {
          "hot": {
            "actions": {
              "rollover": {
                "max_age": "30d",
                "max_size": "50gb"
              }
            }
          },
          "warm": {
            "min_age": "30d",
            "actions": {
              "allocate": {
                "number_of_replicas": 1
              }
            }
          },
          "cold": {
            "min_age": "60d",
            "actions": {
              "allocate": {
                "require": {
                  "data": "cold"
                }
              },
              "freeze": {}
            }
          },
          "delete": {
            "min_age": "90d",
            "actions": {
              "delete": {}
            }
          }
        }
      }
    }
   ```
4. **标签和节点分配**：

   - 使用标签或者自定义属性标识不同类型的数据节点（热节点、冷节点），然后通过 ILM 策略将索引分配到这些节点。

5. **数据迁移**：
   - 根据需要，手动或者自动化地将索引从热节点迁移到冷节点以进行节约和性能优化。

通过适当的热/冷数据管理策略，Elasticsearch 可以更有效地利用系统资源，减少热数据集的压力，同时降低存储成本。

### 如何监控集群健康状况？

监控 Elasticsearch 集群的健康状况对于确保其稳定性和性能至关重要。以下是一些常用的方法和工具，用于监控 Elasticsearch 集群的健康状况：

1. **集群健康 API**：
   - 使用`_cluster/health` API 来快速检查集群的总体健康状态。
   - 返回的信息包括集群的状态（绿色、黄色、红色）、节点数量、正在进行中的分片重新分配等。
     `bash     GET _cluster/health `

- 绿色状态表示所有的分片都正常，黄色状态表示存在具有主分片的索引但是缺乏其副本，红色状态表示存在无法访问的主分片。

2. **集群状态 API**：

   - 使用`_cluster/stats` API 获取集群的详细统计信息，包括文档数量、存储使用情况以及各个节点的详细信息。
     `bash GET _cluster/stats`

3. **节点统计 API**：
   - 节点层面的统计信息可以通过`_nodes/stats` API 获取，包含信息如 CPU 使用率、内存使用、文件系统、线程池等，帮助识别节点级别的问题。
     `bash GET _nodes/stats`

### 如何优化 Elasticsearch 的性能？

优化 Elasticsearch 的性能需要综合考虑索引设计、集群配置和查询效率。以下是一些关键的优化策略：

#### 索引设计优化

1. **合理选择字段类型**：

   - 根据数据类型和使用方式选择合适的字段类型，避免不必要的分析。对于精确匹配，使用`keyword`类型，而非全文分析使用`text`类型。

2. **字段映射优化**：

   - 禁用或者限制不必要的字段索引。对于不需要搜索的字段，设置`index: false`。

3. **分片调整**：
   - 根据数据量和查询需要，适当设置索引的分片数量。过多或过少的分片都会影响性能。一般的经验法则是每个分片大小在 10-50GB 之间。

#### 查询优化

4. **使用过滤**：

   - 对于不需要评分的条件，使用`filter`而不是`query`来提高查询速度，并利用缓存机制。

5. **限制返回字段**：

   - 只请求必要的字段，使用`_source`过滤避免不必要的数据传输。

6. **异步和批量处理**：
   - 尽量使用批量处理（例如使用批量 API）来减少请求数量。

#### 系统和集群配置

7. **硬件配置**：

   - 确保内存（heap size）和 CPU 等资源充裕。通常分配给 Elasticsearch 进程的 JVM 堆内存不要超过总内存的 50%。

8. **异步刷新和合并**：

   - 调整刷新和合并频率。对于写入密集的场景，稍微延迟刷新时间可以减少 I/O 负担。

9. **节点角色优化**：
   - 将不同工作类型分配到不同节点角色如数据节点、主节点和协调节点以优化负载。

#### 日常运维和监控

10. **定期监控和分析**：

    - 使用 Elasticsearch 提供的监控工具（例如 Kibana Monitoring）定期监控集群性能，调整策略。

11. **索引生命周期管理（ILM）**：
    - 使用 ILM 策略自动管理索引的创建、关闭、删除以及冷热数据的定期自动迁移。

通过结合以上策略，能有效提升 Elasticsearch 的查询速度和数据处理效率，同时确保集群的稳定运行。定期分析和调优同样重要，以便及时响应不断变化的负载和需求。

### 哪些因素会影响 Elasticsearch 性能？

Elasticsearch 的性能受多种因素影响，主要包括硬件配置、索引设计、集群设置以及查询模式。以下是一些关键因素：

1. **硬件配置**：

   - **CPU**：CPU 的核心数量和处理能力直接影响查询和索引的速度。
   - **内存**：充足的 RAM 能够提升缓存命中率，减少磁盘 I/O，尤其是对于大数据集。JVM 半数以上的内存通常被分配给堆内存。
   - **磁盘 I/O**：SSD 比 HDD 提供更快的读写速度，这对高频查询和索引任务尤其重要。

2. **索引设计**：

   - **分片数量**：不适当的主分片和副本分片数量会导致内存浪费或 I/O 瓶颈。
   - **字段映射**：复杂或不必要的字段映射会增加索引和查询的复杂性。
   - **文档结构**：扁平化的文档结构通常比深层嵌套结构性能更好。

3. **集群设置**：

   - **节点配置**：角色分配不合理（如所有节点都为主节点或数据节点）会导致性能瓶颈。
   - **网络延迟**：高网络延迟会影响数据节点间的通信和协调节点的响应速度。

4. **查询模式**：

   - **搜索量和频率**：高频繁复杂的查询会增加系统负载，影响响应时间。
   - **过滤 vs 查询**：使用`query`而不是`filter`会导致不必要的评分计算。

5. **索引操作**：

   - **刷新和合并频率**：过于频繁的刷新操作可能导致 CPU 和 I/O 资源浪费。
   - **更新和删除操作**：这些操作需要额外的系统资源进行重建和合并。

6. **系统初始化和垃圾回收**：

   - 启动时的预热和数据加载以及不当的 GC（垃圾回收）配置会影响系统的响应时间。

7. **数据大小和分布**：
   - 数据集的大小及其在索引中的分布方式会影响查找性能。

注意这些因素对于不同的使用场景可以有不同的影响，需要根据具体情况进行诊断和优化。定期的监控和调整是确保 Elasticsearch 性能的关键。

### 解释什么是集群分片再平衡。

集群分片再平衡（Shard Rebalancing）是 Elasticsearch 集群管理中的一个关键功能，旨在保持分片在集群中的均匀分布，从而优化资源利用和提高性能。

#### 分片再平衡的概念

1. **目的**：

   - 确保分片在集群中的节点上均匀分布，以避免单个节点成为瓶颈。
   - 提高故障容错能力，确保副本分片不与其对应的主分片部署在同一个节点上。

2. **触发条件**：

   - 新节点加入集群：当新的数据节点被添加到集群后，Elasticsearch 会自动进行分片再平衡，将数据分片移动到新节点上以均衡负载。
   - 节点离开或故障：系统检测到数据节点离开或故障，会将其上的分片重新分配到其他节点。
   - 手动触发：管理员可以通过 API 手动触发再平衡，调整特定索引或节点的分片配置。

3. **配置和控制**：

   - 可以通过集群设置控制分片再平衡的行为，例如设置集群的再平衡权重、延迟等。
   - 使用 API 限制或调整再平衡的操作以避免影响集群性能，例如在高负载期间抑制再平衡。

4. **优先级**：
   - Elasticsearch 优先恢复数据的高可用性（如主分片恢复）然后才进行性能优化再平衡。

#### 再平衡过程

- Elasticsearch 会自动计算和重新分配需要移动的分片。过程中会尽量减少对集群性能的影响。
- 再平衡的具体实施与各个分片的分配策略有关，通常根据节点负载和分片大小优先进行调整。

分片再平衡使得 Elasticsearch 能够动态响应集群配置的变化，确保持续的高性能和数据的高可用性。这一过程在维护中普遍自动进行，也可以通过配置进行微调。

### 如何使用 Elasticsearch 进行全文检索？

使用 Elasticsearch 进行全文检索是其核心功能之一，下面是实现全文检索的步骤和要点：

#### 配置索引

1.  **定义映射**：
    - 在创建索引时，指定字段的`type`为`text`以支持全文分析和搜索。

`PUT /my_index`

```json
{
  "mappings": {
    "properties": {
      "content": {
        "type": "text"
      }
    }
  }
}
```

2. **分析器（Analyzers）**：

- Elasticsearch 使用分析器将文本分解为词元。默认使用标准分析器，也可以根据语言或需求选择其他分析器（如`english`、`custom`等）。

#### 索引数据

- 将文档索引到 Elasticsearch：

`POST /my_index/_doc`

```json
{
  "content": "Elasticsearch 是一个强大的搜索工具。"
}
```

#### 搜索查询

3. **使用`match`查询**：
   - `match`查询用于执行全文检索，会经过分析器处理从而支持复杂的自然语言搜索。

`GET /my_index/_search`

```json
{
  "query": {
    "match": {
      "content": "搜索工具"
    }
  }
}
```

4. **布尔查询（Boolean Query）**：

- 可以使用`bool`组合多个`match`查询以实现更复杂的检索条件。

`GET /my_index/_search`

```json
{
  "query": {
    "bool": {
      "must": [
        { "match": { "content": "Elasticsearch" } },
        { "match": { "content": "工具" } }
      ]
    }
  }
}
```

#### 结果排序

- 搜索结果按相关性得分排序，得分由 Lucene 评分机制计算。
- 可以通过调整`boost`参数来影响特定字段的权重，从而改变排序。

#### 高亮显示

- 使用`highlight`参数在返回结果中突出显示匹配的文本部分：

`GET /my_index/_search`

```json
{
  "query": {
    "match": {
      "content": "Elasticsearch"
    }
  },
  "highlight": {
    "fields": {
      "content": {}
    }
  }
}
```

以上流程是使用 Elasticsearch 进行全文检索的基本步骤，通过配置适当的映射、索引数据和查询，相结合分析器，还可以进一步优化性能以满足更复杂的搜索需求。

### 点穴更新（Point-in-time）和搜索后分页（Search After）是什么？

点穴更新（Point-in-time）和搜索后分页（Search After）是 Elasticsearch 中用于处理大数据集搜索和分页的机制。

#### 点穴更新 (Point-in-time, PIT)

- **概念**：点穴更新是一种在指定时间点创建数据快照的技术，允许一致地读取数据，即使数据在查询时发生变化。
- **用途**：PIT 特别适合长时间运行的分页操作、深度分页、快照备份等使用场景。
- **优势**：通过 PIT 可以在不断变化的索引上保持一致的视图，从而避免在分页过程中数据偏移或丢失。
- **实现**：在进行分页查询之前，通过建立 PIT 获取当前数据快照。

示例创建 PIT：`POST /my_index/_pit?keep_alive=1m`

### 搜索后分页 (Search After)

- **概念**：搜索后分页是一种高效的分页方式，适合需要从大数据集的某一位置开始分块读取数据的操作。
- **用途**：适用于深度分页，取代传统分页（即从特定“页”开始检索数据页）的高计算代价。
- **优势**：无需计算前面的记录总数，只需根据当前排序结果的最后一个记录开始检索，因此性能更高。
- **实现**：利用结果中的排序属性，将`search_after`参数设置为上一个页的最后一个文档的排序值。

示例使用`search_after`：
`GET /_search`

```json
{
  "size": 10,
  "query": {
    "match_all": {}
  },
  "sort": [{ "timestamp": "asc" }],
  "search_after": [1620000000000]
}
```

结合点穴更新和搜索后分页，可以在处理大数据集时获得一致且高效的查询结果，特别是在需要分页的大型日志或事件数据集中

### 倒排索引

倒排索引（Inverted Index）是 Elasticsearch 等搜索引擎的核心数据结构，用于快速实现全文搜索。与传统的正排索引不同，倒排索引将文档中的内容映射到包含该内容的文档，而不是文档到内容的映射。

#### 倒排索引的工作原理

1. **文档分词**：将文档内容通过分词器（Tokenizer）分解成一个个词项（Term）。
2. **建立词项到文档的映射**：记录每个词项出现在哪些文档中，并保存词项的位置、频率等信息。
3. **查询优化**：通过倒排索引快速找到包含特定词项的文档，而不需要扫描所有文档。

#### 示例

假设有以下文档：

- 文档 1：`Elasticsearch is fast`
- 文档 2：`Elasticsearch is powerful`
- 文档 3：`Lucene is the core`

倒排索引将构建如下：

```bash
"elasticsearch" -> [文档1, 文档2]
"is"           -> [文档1, 文档2, 文档3]
"fast"         -> [文档1]
"powerful"     -> [文档2]
"lucene"       -> [文档3]
"the"          -> [文档3]
"core"         -> [文档3]
```

#### 倒排索引的优势

- **高效查询**：通过索引词项直接定位文档，大大减少查询时间。
- **支持复杂查询**：支持布尔查询、短语查询、模糊查询等高级搜索功能。
- **灵活分析**：支持分词器、同义词、停用词等文本分析功能。

#### 倒排索引的组成部分

- **词典（Term Dictionary）**：存储所有唯一的词项。
- **倒排表（Postings List）**：记录每个词项对应的文档列表及词频、位置等信息。

#### 在 Elasticsearch 中的应用

- Elasticsearch 为每个字段（如`text`类型的字段）创建一个倒排索引。
- 倒排索引存储在 Lucene 中，由 Elasticsearch 分布式管理。

倒排索引是全文搜索的核心，是实现高效检索的关键技术。理解其工作原理有助于更好地优化搜索性能。

### mapping 设计技巧

### 分片分配策略

Elasticsearch 的分片分配策略是确保集群性能、数据冗余和负载均衡的核心机制。以下是分片分配策略的详细说明和优化建议：

### 1. **分片分配基础**

- **主分片（Primary Shard）**：存储数据的主力分片，每个文档会被分配到一个主分片中。
- **副本分片（Replica Shard）**：主分片的副本，用于提高数据冗余和查询性能。

### 2. **分片分配策略**

- **负载均衡**：Elasticsearch 会自动将分片均匀分布在集群中的节点上，以避免单个节点负载过高。
- **故障恢复**：如果某个节点宕机，其分片会重新分配到其他可用节点上。
- **机架感知（Rack Awareness）**：通过配置`cluster.routing.allocation.awareness.attributes`，确保分片及其副本分布在不同的物理机架或可用区，提高容错能力。

### 3. **分片分配设置**

- **节点属性分配**：使用`index.routing.allocation.include`、`index.routing.allocation.exclude`和`index.routing.allocation.require`来控制分片分配到特定节点。例如：

`PUT /my_index/_settings`

```json
{
  "index.routing.allocation.include.zone": "us-east1"
}
```

- **分片过滤**：通过节点标签或自定义属性，限制分片只能分配到特定节点。

### 4. **动态分片管理**

- **手动分配**：使用`_cluster/reroute` API 手动移动分片，例如：
  `POST /_cluster/reroute`

  ```json
  {
    "commands": [
      {
        "move": {
          "index": "my_index",
          "shard": 0,
          "from_node": "node1",
          "to_node": "node2"
        }
      }
    ]
  }
  ```

- **分片恢复**：通过`cluster.routing.allocation.node_initial_primaries_recoveries`和`cluster.routing.allocation.node_concurrent_recoveries`控制分片恢复的并发数。

### 5. **分片分配优化**

- **分片大小控制**：每个分片的大小建议控制在 10GB 到 50GB 之间，避免分片过大或过小。
- **分片数量优化**：根据数据量和查询负载合理设置分片数量。过多的分片会增加集群管理开销，过少的分片可能导致查询性能下降。
- **分片均衡**：可以使用`_cluster/reroute` API 或`_cluster/settings` API 动态调整分片分配策略。

### 6. **避免热点问题**

- **路由优化**：使用自定义路由将特定数据分配到固定分片，避免热点分片。
- **查询负载均衡**：确保查询请求均匀分布在所有分片上。

### 7. **监控与调整**

- 使用`_cat/shards` API 监控分片分配状态。
- 定期检查集群健康和分片分布情况，优化分片分配策略。

通过合理设计分片分配策略，可以显著提高 Elasticsearch 集群的性能、可用性和可扩展性。务必结合业务需求和硬件环境进行优化。

### 深分页问题

使用 scroll API 对大数据量查询

- 会生成数据快照，适合非实时的大批量数据导出
- 需要管理 scroll_id 的生命周期

scroll API 生命周期的关键步骤:

**存活时间控制**

- 在初始请求中通过 ?scroll=1m 参数设置上下文存活时间（示例使用 1 分钟）
- 每次续期时会重置倒计时（最后一次请求后开始倒计时）

**显式删除 scroll_id**

```bash
# 单个删除
curl -X DELETE "{{ES_HOST}}/_search/scroll" -H 'Content-Type: application/json' -d'
{
  "scroll_id" : "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVY..."
}'

# 批量删除所有历史
curl -X DELETE "{{ES_HOST}}/_search/scroll/_all"
```

**存活时间推荐参数**

- 大数据量（百万级）：设置 10-30 分钟
- 常规场景：控制在 1-5 分钟内
- 配合管道处理时：设置略长于预估处理时间

**监控方法**

```bash
# 查看当前活跃的 scroll 上下文
curl -X GET "{{ES_HOST}}/_nodes/stats/indices/search?pretty"
```

### refresh vs flush

### 如何使用 PIT（Point-in-Time）+ search_after 优化分页查询

使用 PIT（Point-in-Time）配合 search_after 实现安全分页的步骤：

1. **创建 PIT（有效期为 5 分钟）**

```bash
curl -X POST "{{ES_HOST}}/index/_pit?keep_alive=5m"
# 返回结果示例：
{ "id": "48gkwmdlKG..." } # 保存这个 pit_id
```

2. **首次查询**

```bash
curl -X GET "{{ES_HOST}}/_search" -H 'Content-Type: application/json' -d'
{
  "size": 100,
  "pit": {
    "id": "{{PIT_ID}}",
    "keep_alive": "5m"
  },
  "sort": [
    { "timestamp": "desc" },
    { "_id": "asc" }
  ]
}'
# 搜索结果中会返回新的 pit_id 用于后续查询
```

3. **后续分页（使用 search_after）**

```bash
curl -X GET "{{ES_HOST}}/_search" -H 'Content-Type: application/json' -d'
{
  "size": 100,
  "pit": {
    "id": "{{NEW_PIT_ID}}",
    "keep_alive": "5m"
  },
  "sort": [
    { "timestamp": "desc" },  # 排序字段必须与首次查询一致
    { "_id": "asc" }
  ],
  "search_after": [
    "2025-02-24T12:34:56",    # 使用上一次结果最后的排序值
    "document_id_123"
  ]
}'
```

4. **显式关闭 PIT（立即释放资源）**

```bash
curl -X DELETE "{{ES_HOST}}/_pit" -H 'Content-Type: application/json' -d'
{
  "id" : "{{PIT_ID}}"
}'
```

工作特点：

- PIT 会在 keep_alive 时间后自动清理（无需强制删除）
- 分页全程使用快照保证数据一致性
- 相比 Scroll API 更节约内存资源
- 最多支持 100 个并行 PIT 会话
